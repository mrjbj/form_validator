# Overview

## Intro - Background and Purpose

Welcome to the livebook demo for form_validator, an sample project intending to show
how to use Ash framework in a Phoenix LiveView project to create, retrieve, update, and
delete a parent/child data relationship in a single data entry form.

Database model is `users` and `tweets`. There are many tweets per user but only one user per tweet.

Access to `User` and `Tweet` structures is mediated through Ash framework, which
encapsulates database data at a table level through an Ecto.Schema like module called a "resource".
 `Ash.Resources` define both the structure of a database table, (e.g., "attributes",
"validations", or "virtual fields" called "aggregates" or "calculations") as well as the `actions` or methods that 
can be used to retrieve, manipulate and persist that data through to the database.

Remainder of this livebook flows along the following path -  first we connect livebook to the database
and add in some sample data.  Then, we'll read, update, and delete that data dealing with each table as a
standalone entity. After that, we'll figure out how to manage the parent/child relationship between users and
tweets, then we'll try and expose that backend up through a single, parent/child data entry form, using
Ash.PhoenixForm.

## Data Model - Users & Tweets

`Ash.Resources` are by convention placed in the `./lib/resource/` directory, with one "schema" module defined for each table.  In our example, that would be `./lib/resource/user.ex` for Users, or `./lib/resource/tweet.ex` for Tweets.

If you pause for a moment and go take a look at thes files, you'll notice that they specify both the 
structure of the database, as well as the validations and update actions used to maintain it. The syntax for specifying 
resources is fully laid out in the documentation under `Ash.Resource.Dsl` but highlights include `attribute` for specifying physical database columns, 
`calculations` and `aggregates` for specifying virtual columns, `validations` for ensuring good data, and `actions` to control how to persist data to the databse. 
Resources also handle other things like access control, multi-tennancy, etc.  Check out `Ash.Resource.Dsl` in the documentation for full details.

**Introspection:** If you want to interactively explore your resources, `Ash.Resource.Info` has some introspection functions, so you can type stuff 
into IEx like `Ash.Resource.Info.attributes(User)` to show you the fields defined for the User,
or `Ash.Resource.Info.actions(User)` will show the methods you can use to interact with it.

For our livebook sample applications there are two resources defined: 
`Ash.Resource.User` has `[:id, :email, :username, :password, :inserted_at, :updated_at]`. 
`Ash.Resource.Tweet` is: `[:id, at, :updated_at]`

### Startup Database, take a look around.

Launch the Ecto.Repo via start_link(), setup some useful aliases, and take a look at the structure.

```elixir
# setup require and aliases
require Ash.Query
alias FormValidator.{User, Tweet, Api}

# launch repo process
FormValidator.Repo.start_link()

# see what resources are available 
Ash.Api.resources(Api)

# iterate through User's "attributes" and "actions" 
Enum.each(Ash.Resource.Info.attributes(User), fn x -> IO.inspect(x.name, label: "attribute: ") end)

Enum.each(Ash.Resource.Info.actions(User), fn x -> IO.inspect(x.name, label: "action: ") end)

# do the same for Tweet 
Enum.each(Ash.Resource.Info.attributes(Tweet), fn x ->
  IO.inspect(x.name, label: "attribute: ")
end)

Enum.each(Ash.Resource.Info.actions(Tweet), fn x -> IO.inspect(x.name, label: "action: ") end)
```

### Add some new Users

Make a list of new user emails and then add them, one at a time.

```elixir
# --  NOTE: Throughout this livebook, you may notice bindings being assigned to expressions pipelined 
# -- across multiple lines of text. If you try to cut and paste multi-line expressions from a pipeline into IEx, 
# --  the binding often won't work because IEx evaluates expressions one line at a time. 
# -- the solution is to either place the |> token at end of each line or join all of the lines
# -- together into one, big line and then paste that into IEx.

# create list of users
list_of_users = [
  "alice@wonderland.com",
  "joe@volcano.com",
  "sam@wainwright.com",
  "james@marfugi.com",
  "mary@littlelamb.com"
]

# iterate through list, adding one user at a time.
users_added =
  Enum.reduce(list_of_users, 0, fn item, acc ->
    # Struct -> Changeset -> Resource
    User
    |> Ash.Changeset.new(%{email: item})
    |> Api.create()

    acc + 1
  end)

IO.inspect(users_added, label: "Users added: ")
```

### Add some new Tweets

Do the same for Tweets, worrying only about the :body attribute.  Add them to the database one at a time.

```elixir
# list
list_of_tweets = [
  "Phoenix LiveView + OTP means scalable real-time goodness.",
  "Tweet 2",
  "Tweet 3",
  "Tweet 4",
  "Tweet 5"
]

# iterate through list, adding one tweet at a time.
tweets_added =
  Enum.reduce(list_of_tweets, 0, fn item, acc ->
    # Struct -> Changeset -> Resource
    Tweet
    |> Ash.Changeset.new(%{body: item})
    |> Api.create()

    acc + 1
  end)

IO.inspect(tweets_added, label: "Tweets added: ")
```

## CRUD Operations

### Reading Data

The api layer handles interactions with the database, so just like `Api.create()` is used to *save* new records to the database, `Api.read()` is used to *retrieve* data instead.
Before we can understand how to read, though, we need to understand `Ash.Query` first.

### Querying Data

Ash.Query contains a bunch of functions that facilitate data retrieval. The full list is available in the documentation at `Ash.Query` 
or you can interactively explore it in IEx by typing "Ash.Query." (with the "dot") and then hitting TAB to expand to show all of its functions.
(For fun, try typing in `h Ash.Query.filter` into IEx to see the command line docs on filter).
There many query functions, but the main ones to get started include `filter`, `sort` and `load`. 
Filter includes or excludes certain rows from the result set, while load pre-loads related tables, sort sorts, and `offset` and `limit` are useful for pagination.

**Filtering:** Query.filter takes a resource and a filter expression, which can be specified in either *keyword* or *expression* style syntax.  Here is example below:

```elixir
# No query, just read(<ResourceName>) to return "select all" 
Api.read(User)

# Query.filter using keyword style syntax.
User
|> Ash.Query.filter(email: "james@marfugi.com")
|> Api.read()

# Query.filter using expression style syntax.
User
|> Ash.Query.filter(email == "james@marfugi.com")
|> Api.read()
```

### Loading Related Data

`Query.load` is used to preload related tables. Note that it doesn't have to have a Query.filter on it first, but can.

```elixir
# Query.load using keyword style syntax. This result will show `[]` for associated tweets because their haven't been any linked into a user yet.
User
|> Ash.Query.load(:tweets)
|> Api.read()

# Query.filter using expression style syntax.
User
|> Ash.Query.filter(email == "james@marfugi.com")
|> Ash.Query.load(:tweets)
|> Api.read()
```

### Sorting & Select

`Query.sort` is used for sorting and `Query.select` is used to include or remove columns from the result set. IEx will still show all of the
attributes via IO.inspect() to the screen (because the User %Struct{} defines them), but those attributes not "selected" in the `Ash.Query.select()` result, will be be set to `nil`.

```elixir
# Query.load using keyword style syntax. Won't show any related tweets yet because they haven't been linked to users yet.
User
|> Ash.Query.sort([:email])
|> Ash.Query.select([:email, :username])
|> Api.read()
```

### Pagination

TO COME

```elixir
# todo 
```

## Relationships

### Defining Relationships

Relationships are defined in Ash.Resource (e.g., in `user.ex` or `tweet.ex`) and "managed" through functions expecting an `Ash.Changeset`. 
When defining the child side of a parent/child relation, you don't need to specify the foriegn keys explicitly, since Ash will create and use one for you automatically, using the convention of <relationship_name>_id, (e.g., `tweet.user_id`).

```
# .. from tweet.ex (foreign key "user_id" is implicitly defined by convention)

defmodule FormValidator.Tweet do
  # ... snip ...
  # note -> :user_id is implicity defined
  relationships do
    belongs_to :user, FormValidator.User
  end
end
```

Of course, it's still possible to define them explicitly if you prefer, though this is not generally recommended, since there's a lot less noise in the code once you get comfortable with the idea that the foreign keys are still actually there, just working for you behind the scenes.  Here's how to define foreign key explicitly:

```
# From tweet.ex 
# - foreign key is defined explicitly via "attribute" 
# - automatic foreign key generation is "turned off" in relationships via "define_field? false" 

defmodule FormValidator.Tweet do
  # ... snip ...
  
  attribute :user_id, :uuid
  
  relationships do
    belongs_to :user, FormValidator.User
    define_field? false
  end
end
```

### Managing Relationships - Configuration.

Relationships are manipulated primarily through the `manage_relationship` function that takes in an Ash.Changeset along with a set of potential changes that are passed in as either a single map, a list of maps or an `Ash.Identity` value. (Collectively, this is called "input").  Changes are applied from both sides, first by comparing the "input" to the "changeset" and then comparing the "changeset" to the proposed "input" changes.  
Processing on the "input-to-changeset" side begins first and is configured through `:on_lookup`, `:on_match`, and `:on_no_match` options that specify the control logic to use depending upon whether the input item was found in the changeset or not. 
Matches are found based upon the primary key, so it or some other `Ash.Identity` should be present in the input. If an input item is found in the changeset, then the `:on_match` behavior is invoked, but if not found, then `:on_lookup` behavior is triggered to go and retrieve it from the database instead.  At that point, either `:on_match` or `:on_no_match` is invoked depending upon whether the item was found or not in the databsae. (`:on_no_match` is also invoked if `:on_lookup` was not specified or set to `:ignore`).

Next, after "input-to-changeset" processing has completed, the "changeset-to-input" process begins, examining each changeset item for a corresponding match on the input side. In this case, `:on_missing` logic triggered for any changeset item not found in the corresponding input map.  The end result of these two processes can be visualized declaratively in the diagram below:
![](images/manage_relationship_diagram.jpg)

### Managing Relationships - Operation Types

Rather than have to remember and specify each of these control options individually, we can instead group them together into an "operation type" that makes common manipulation settings easier. Operation types are specified via the `:type` option and correspond to the specifications below:

```
:replace --> [on_lookup: :relate, on_no_match: :error, on_match: :ignore, on_missing: :unrelate]
:append --> [on_lookup: :relate, on_no_match: :error, on_match: :ignore, on_missing: :ignore]
:remove  --> [on_no_match: :error, on_match: :unrelate, on_missing: :ignore]
:direct_control --> [on_lookup: :ignore, on_no_match: :create, on_match: :update, on_missing: :destroy]
:create --> [on_no_match: :create, on_match: :ignore]
```

### Managing Relationships - Aliases

Finally, as an alternative to specifying operation types or setting relationship configuration options granularly, three function aliases are also available that encapsulate common settings for adding, replacing or removing relations in code.  The grandular approach is commonly used when defining "actions" inside of your "resources" while the operation types and aliased functions are more commonly used in code.

```
append_to_relationship/4 is an alias for manage_relationship with operation type of :append. 
replace_relationship/4 is an alias for manage_relationship with operation type of :replace. 
remove_from_relationship/4 is an alias for manage_relationship with operation type of :remove
```

### Relationships Examples
#### Example 1: Create a new child and save it (from Parent's point of view) 
First, we demonstrate how to `:create`  a new child linked to an existing parent. We retrieve "james@marfugi.com" as sample user, define some new content to serve as the tweet, insert that tweet into the changeset via `manage_relationship` and finally, persist it to the database via `Api.update()`
```elixir
# retrieve "james@marfugi.com" as parent into changeset. 
james_changeset =
  User
  |> Ash.Query.filter(email: "james@marfugi.com")
  |> Api.read_one!()
  |> Ash.Changeset.new()

# specify input data to serve as content for the new tweet. 
input_tweet_data = %{body: "This is a new tweet from James"}

# insert `input_tweet_data` into the changeset via Ash.Changeset.manage_relationship
# note {tweet.user_id} will be added in by `manage_relationship` implicitly 
james_with_tweet_changeset = Ash.Changeset.manage_relationship(james_changeset, :tweets, input_tweet_data, type: :create)

# persist to the database. 
# tweet.user_id will be saved in in the SQL INSERT statement generated for us. 
# note: from Api point of view, the change is an update, since "updating" or changing the set of 
#        tweets tied to user.  We are adding Tweets, but chainging User.
Api.update(james_with_tweet_changeset)
```
**Pipeline Through in One Step:** We also join each step through together through elixir pipeline as in the same, but more compact example, below. 
```elixir
User
|> Ash.Query.filter(email: "james@marfugi.com")
|> Api.read_one!()
|> Ash.Changeset.new()
|> Ash.Changeset.manage_relationship(:tweets, %{body: "another new tweet from james"}, type: :create)
|> Api.update()
```
#### Example 2: Update children's foreign key pointer to change its relationship to parent (from Child's point of view). 
This example takes all of the tweets we created so far and assigns them to user "james@marfugi.com", which shows us how to update a child's foreign key pointer to its parent. 
First, we retrieve the :id of James from the database and save it as a variable. Next, we retrieve all of the tweets from the database and save them in a list.  From there, we iterate across each item in the list, transforming each tweet into an Ash.Changeseet, changing it's `user_id` foreign key to james.id and saving back to the database.  Note that we have to use `Ash.Changeset.force_change_attribute` rather than regular `change_attribute` because remember, the user_id foreign key is being managed for us by Ash and is therefore set to "not writable" by default.  `force_change_attribute` allows us to override this.

TODO: is this a valid example?  Does it make sense to update relationship from the child side in this way? Is there a better manage_relationship variant for this? 
```elixir
# get james@marfugi's :id from the database. 
james_id =
  User
  |> Ash.Query.filter(email: "james@marfugi.com")
  |> Ash.Query.load(:tweets) 
  |> Api.read_one!()
  |> Map.get(:id)
james_user =
  User
  |> Ash.Query.filter(email: "james@marfugi.com")
  |> Ash.Query.load(:tweets) 
  |> Api.read_one!()

# get all the tweets, and save into list of %Tweets{} 
tweet_list = Api.read!(Tweet) 

# iterate through each one, set it's user_id to `james_id` and persist to the database. 
Enum.each(tweet_list, fn tweet -> Ash.Changeset.new(tweet) |> Ash.Changeset.force_change_attribute(:id, james_id) |> IO.inspect(label: "again ") end)
Enum.each(tweet_list, fn tweet -> Ash.Changeset.new(tweet) |> Ash.Changeset.force_change_attribute(:id, james_id) |> Api.update!() end)
```
#### Example 3: Remove Tweet from User (DRAFT)
If we want to remove one tweet from a user, we need a way of identifying which one we want to delete, so in this case we *do** want an identity value of some kind, even if that's just the index of a preloaded enum participating as the child in the parent's changeset.  This might apply when a "delete" button is clicked on a HTML form, for example. The form sends in a value that is used to drive the match in comparision to the changeset's enum of tweets.  In this example, we'll peel off the first tweet from the top of the enum and use it's primary key (`tweet.id`) as the identifier used as input to drive the behavior `manage_relationship` by matching to that value with the `on_match:` instruction to `:destroy`.  

It's important to note that instruction is `:destroy`, not `:remove` for deleting. Remove only disassociates the link or relationship, setting foreign_key to nil, it does not actually remove it from the databse.  Destroy will actually delete it.   

It's also to note that when we're trying to delete or remove children from the parent, we doing so from the perspective of the parent. This means when we specify `on_match: :destroy` in the example, we're talking about "tweets" that we want to destroy, but when we want to save to the databse, we're doing so from the perspective of the parent `User`, which essentially amounts to an "update" to a set of tweets that is now smaller than before.  That's why we call `Api.update()` rather than `Api.destroy()` at the end of the expression.

```elixir
# retrieve james preloaded with all of his tweets 
james_changeset = 
  User 
  |> Ash.Query.filter(email: "james@marfugi.com") 
  |> Ash.Query.load(:tweets) 
  |> Api.read_one!() 
  |> Ash.Changeset.new()

# pick-out first associated tweet and use the tweet.id from that as the one to delete. 
input = %{id: Enum.at(james_changeset.data.tweets, 0).id}

Ash.Changeset.manage_relationship(james_changeset, :tweets, input, on_match: :destroy)
|> Api.update()
```

#### Example 4: Update Existing Tweet from User (DRAFT)

Updating an existing tweet from parent side is essentially the same as example 2 above, except in this case, we specify an operation type of :update instead of :remove, and a call to Api.update() rather than Api.destroy()

```elixir
# retrieve james preloaded with all of his tweets 
james_changeset =
  User
  |> Ash.Query.filter(email: "james@marfugi.com")
  |> Ash.Query.load(:tweets)
  |> Api.read_one!()
  |> Ash.Changeset.new()

# pick-out tweet.id from james's first tweet.
input = %{id: Enum.at(james_changeset.data.tweets, 0).id, body: "Updated tweet now!"}

Ash.Changeset.manage_relationship(james_changeset, :tweets, input, type: :update)
|> Api.update()
```

## Changesets

`Changesets.new` is used when you want a "light touch" on validations as when working with internal data that you know is already sound.   Use "Changeset.<for_action>" (e.g. `Changeset.for_create/2`, `Changeset.for_destroy/3`, `Changeset.for_update/4`) when working with data entered by user or flowing-in from external system, since the validations applied there will align with the type of "for_action" being applied.

A changeset created with new will not be persisted to database while one created with "for_create" will.

```elixir
# internal data, will be valid
loose_validation = Ash.Changeset.new(User)
IO.inspect(loose_validation.valid?, label: "Is Changeset.new() valid?")

# validation is more rigorous using "for_create" than just "new"
strict_validation_missing_email = Ash.Changeset.for_create(User, :create, %{})
# false
IO.inspect(strict_validation_missing_email.valid?, label: "Is Changeset.for_create() valid?: ")

# passes validations, true
strict_validation_has_email =
  Ash.Changeset.for_create(User, :create, %{email: "super@de-duper.com"})

IO.inspect(strict_validation_has_email.valid?, label: "Is Changeset.for_create valid now?: ")
```
